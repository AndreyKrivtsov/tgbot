import type { IService } from "../../core/Container.js"
import type { Logger } from "../../helpers/Logger.js"
import type { AppConfig } from "../../config.js"
import { ChatAiRepository } from "../../repository/ChatAiRepository.js"
import type { GeminiMessage } from "../AI/providers/GeminiAdapter.js"
import { GeminiAdapter } from "../AI/providers/GeminiAdapter.js"
import type { Chat, ChatConfig, SystemPromptData } from "../../db/schema.js"
import type { NodePgDatabase } from "drizzle-orm/node-postgres"

interface AIChatDependencies {
  aiService?: any
  database?: NodePgDatabase<any>
}

interface ChatContext {
  chatId: string
  messages: ChatMessage[]
  lastActivity: number
  requestCount: number
  dailyRequestCount: number
  lastDailyReset: number
}

interface ChatMessage {
  role: "user" | "assistant"
  content: string
  timestamp: number
}

interface MessageQueue {
  id: number
  message: string
  contextId: string
  timestamp: number
  retryCount: number
}

/**
 * –°–µ—Ä–≤–∏—Å AI —á–∞—Ç-–±–æ—Ç–∞ –¥–ª—è –æ–±—â–µ–Ω–∏—è —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ —á–µ—Ä–µ–∑ Gemini
 */
export class AIChatService implements IService {
  private config: AppConfig
  private logger: Logger
  private dependencies: AIChatDependencies
  private chatContexts: Map<string, ChatContext> = new Map()
  private messageQueue: MessageQueue[] = []
  private isProcessingQueue = false
  private nextMessageId = 1
  private dailyLimit = 1500
  private throttleDelay = 3000 // 3 —Å–µ–∫—É–Ω–¥—ã –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
  private chatAiRepository?: ChatAiRepository
  private chatSettings: Map<number, { chat: Chat | null, config: ChatConfig | null }> = new Map() // –ö—ç—à –Ω–∞—Å—Ç—Ä–æ–µ–∫ —á–∞—Ç–æ–≤

  constructor(config: AppConfig, logger: Logger, dependencies: AIChatDependencies = {}) {
    this.config = config
    this.logger = logger
    this.dependencies = dependencies

    if (dependencies.database) {
      this.chatAiRepository = new ChatAiRepository(dependencies.database)
    }
  }

  /**
   * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Ä–≤–∏—Å–∞ AI —á–∞—Ç–∞
   */
  async initialize(): Promise<void> {
    this.logger.i("ü§ñ Initializing AI chat service...")

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã –∏–∑ –ë–î –µ—Å–ª–∏ –µ—Å—Ç—å
    await this.loadChatContexts()

    this.logger.i("‚úÖ AI chat service initialized")
  }

  /**
   * –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ AI —á–∞—Ç–∞
   */
  async start(): Promise<void> {
    this.logger.i("üöÄ Starting AI chat service...")

    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—á–µ—Ä–µ–¥–∏
    this.startQueueProcessor()

    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ—á–∏—Å—Ç–∫—É —Å—Ç–∞—Ä—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
    this.startContextCleanup()

    this.logger.i("‚úÖ AI chat service started")
  }

  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ AI —á–∞—Ç–∞
   */
  async stop(): Promise<void> {
    this.logger.i("üõë Stopping AI chat service...")
    this.isProcessingQueue = false

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã –≤ –ë–î
    await this.saveChatContexts()

    this.logger.i("‚úÖ AI chat service stopped")
  }

  /**
   * –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤
   */
  async dispose(): Promise<void> {
    this.logger.i("üóëÔ∏è Disposing AI chat service...")
    await this.stop()
    this.chatContexts.clear()
    this.messageQueue = []
    this.logger.i("‚úÖ AI chat service disposed")
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞
   */
  isHealthy(): boolean {
    return this.dependencies.aiService !== undefined
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞—â–µ–Ω–∏–µ–º –∫ –±–æ—Ç—É
   */
  isBotMention(message: string, botUsername?: string): boolean {
    if (!message || message.trim().length === 0) {
      return false
    }

    const text = message.toLowerCase().trim()

    // –ü—Ä—è–º–æ–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ —á–µ—Ä–µ–∑ @username
    if (botUsername && text.includes(`@${botUsername.toLowerCase()}`)) {
      return true
    }

    // –û–±—Ä–∞—â–µ–Ω–∏–µ "—ç–π –±–æ—Ç", "–∞–ª—å—Ç—Ä–æ–Ω" –∏ —Ç.–¥.
    const botTriggers = [
      /^—ç–π.{0,3}–±–æ—Ç\W?/i,
      /^–∞–ª—å—Ç—Ä–æ–Ω/gi,
      /^–±–æ—Ç[,\s]/i,
    ]

    for (const trigger of botTriggers) {
      if (trigger.test(text)) {
        return true
      }
    }

    return false
  }

  /**
   * –û—á–∏—Å—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç —É–ø–æ–º–∏–Ω–∞–Ω–∏–π –±–æ—Ç–∞
   */
  cleanBotMention(message: string, botUsername?: string): string {
    let cleaned = message.trim()

    // –£–±–∏—Ä–∞–µ–º @username
    if (botUsername) {
      cleaned = cleaned.replace(new RegExp(`@${botUsername}`, "gi"), "").trim()
    }

    // –£–±–∏—Ä–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –æ–±—Ä–∞—â–µ–Ω–∏—è
    cleaned = cleaned.replace(/^—ç–π.{0,3}–±–æ—Ç\W?/i, "").trim()
    cleaned = cleaned.replace(/^–∞–ª—å—Ç—Ä–æ–Ω\W?/gi, "").trim()
    cleaned = cleaned.replace(/^–±–æ—Ç[,\s]/i, "").trim()

    return cleaned || message
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è AI
   */
  async processMessage(
    userId: number,
    chatId: number,
    message: string,
    username?: string,
    firstName?: string,
    _isReply?: boolean,
  ): Promise<{
      success: boolean
      queued: boolean
      reason?: string
      queuePosition?: number
    }> {
    try {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã
      const limitCheck = await this.checkDailyLimit(chatId.toString())
      if (!limitCheck.allowed) {
        return {
          success: false,
          queued: false,
          reason: limitCheck.reason,
        }
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏
      if (this.messageQueue.length >= 8) {
        return {
          success: false,
          queued: false,
          reason: "–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –æ—á–µ—Ä–µ–¥–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
        }
      }

      // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è AI
      const cleanedMessage = this.cleanBotMention(message)
      const contextualMessage = this.prepareContextualMessage(
        cleanedMessage,
        username,
        firstName,
      )

      // –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å
      const queueItem: MessageQueue = {
        id: this.nextMessageId++,
        message: contextualMessage,
        contextId: chatId.toString(),
        timestamp: Date.now(),
        retryCount: 0,
      }

      this.messageQueue.push(queueItem)

      this.logger.d(`Added message to queue from ${firstName} (${userId}): ${cleanedMessage}`)

      return {
        success: true,
        queued: true,
        queuePosition: this.messageQueue.length,
      }
    } catch (error) {
      this.logger.e("Error processing message:", error)
      return {
        success: false,
        queued: false,
        reason: "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è",
      }
    }
  }

  /**
   * –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
   */
  private prepareContextualMessage(
    message: string,
    username?: string,
    firstName?: string,
  ): string {
    const date = new Date()
    const messageDate = date.toISOString().replace(/:\d+\.\d+Z/gi, "").replace("T", " ")

    const userInfo = firstName
      ? (username ? `@${username}][${firstName}` : `${firstName}`)
      : (username ? `@${username}` : "–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å")

    return `[${messageDate}][${userInfo}] –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç —Ç–µ–±—è: ${message}`
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
   */
  private async checkDailyLimit(contextId: string): Promise<{
    allowed: boolean
    reason?: string
    remaining: number
  }> {
    const context = this.getOrCreateContext(contextId)

    // –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –µ—Å–ª–∏ –ø—Ä–æ—à–µ–ª –¥–µ–Ω—å
    const now = Date.now()
    const dayInMs = 24 * 60 * 60 * 1000
    if (now - context.lastDailyReset > dayInMs) {
      context.dailyRequestCount = 0
      context.lastDailyReset = now
    }

    const dailyLimit = this.dailyLimit
    const remaining = dailyLimit - context.dailyRequestCount

    if (context.dailyRequestCount >= dailyLimit) {
      return {
        allowed: false,
        reason: `–ü—Ä–µ–≤—ã—à–µ–Ω –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤ (${dailyLimit}). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–≤—Ç—Ä–∞.`,
        remaining: 0,
      }
    }

    return {
      allowed: true,
      remaining,
    }
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —á–∞—Ç–∞
   */
  private getOrCreateContext(contextId: string): ChatContext {
    let context = this.chatContexts.get(contextId)

    if (!context) {
      const now = Date.now()
      context = {
        chatId: contextId,
        messages: [],
        lastActivity: now,
        requestCount: 0,
        dailyRequestCount: 0,
        lastDailyReset: now,
      }
      this.chatContexts.set(contextId, context)
    }

    context.lastActivity = Date.now()
    return context
  }

  /**
   * –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
   */
  private startQueueProcessor(): void {
    if (this.isProcessingQueue)
      return

    this.isProcessingQueue = true

    const processNext = async () => {
      if (!this.isProcessingQueue)
        return

      try {
        const queueItem = this.messageQueue.shift()

        if (queueItem) {
          await this.processQueuedMessage(queueItem)
        }
      } catch (error) {
        this.logger.e("Queue processing error:", error)
      }

      // –ü–ª–∞–Ω–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
      setTimeout(processNext, 1000)
    }

    processNext()
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –æ—á–µ—Ä–µ–¥–∏
   */
  private async processQueuedMessage(queueItem: MessageQueue): Promise<void> {
    try {
      const context = this.getOrCreateContext(queueItem.contextId)

      // –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ AI —Å throttling
      await this.throttledAIRequest(queueItem)

      context.requestCount++
      context.dailyRequestCount++
    } catch (error) {
      this.logger.e("Error processing queued message:", error)

      // Retry logic
      if (queueItem.retryCount < 3) {
        queueItem.retryCount++
        this.messageQueue.push(queueItem)
        this.logger.w(`Retrying message ${queueItem.id}, attempt ${queueItem.retryCount}`)
      }
    }
  }

  /**
   * –ó–∞–ø—Ä–æ—Å –∫ AI —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏
   */
  private async throttledAIRequest(queueItem: MessageQueue): Promise<void> {
    try {
      // –≠–º–∏—Ç–∏—Ä—É–µ–º typing –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
      this.onTypingStart?.(queueItem.contextId)

      const chatId = Number.parseInt(queueItem.contextId)

      // –ü–æ–ª—É—á–∞–µ–º API –∫–ª—é—á –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —á–∞—Ç–∞
      const apiKey = await this.getApiKeyForChat(chatId)
      const chatLimits = await this.getChatLimits(chatId)

      // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      const context = this.getOrCreateContext(queueItem.contextId)

      // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
      context.messages.push({
        role: "user",
        content: queueItem.message,
        timestamp: Date.now(),
      })

      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∏—Å—Ç–æ—Ä–∏—é –≤ —Ñ–æ—Ä–º–∞—Ç Gemini
      const conversationHistory: GeminiMessage[] = context.messages.map(msg => ({
        role: msg.role === "assistant" ? "model" : "user",
        parts: [{ text: msg.content }],
      }))

      // –°–æ–∑–¥–∞–µ–º –∞–¥–∞–ø—Ç–µ—Ä (–±–µ–∑ API –∫–ª—é—á–∞ –≤ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–µ)
      const geminiAdapter = new GeminiAdapter()

      // –î–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫ Gemini API, –ø–µ—Ä–µ–¥–∞–≤–∞—è API –∫–ª—é—á –∏ –∏—Å—Ç–æ—Ä–∏—é
      const response = await geminiAdapter.generateContent(
        apiKey,
        queueItem.message,
        conversationHistory,
      )

      if (response && response.trim()) {
        // –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        context.messages.push({
          role: "assistant",
          content: response,
          timestamp: Date.now(),
        })

        // –ü—Ä–æ—Å—Ç–∞—è –æ–±—Ä–µ–∑–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ - –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π
        if (context.messages.length > 10) {
          context.messages = context.messages.slice(-10)
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        this.onMessageResponse?.(queueItem.contextId, response, queueItem.id)

        this.logger.d(`AI response sent for message ${queueItem.id}`)
      } else {
        this.logger.w(`Empty AI response for message ${queueItem.id}`)
      }

      // –ñ–¥–µ–º –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–∞—Ç–∞)
      await new Promise(resolve => setTimeout(resolve, chatLimits.throttleDelay))
    } catch (error) {
      this.logger.e("AI request error:", error)
      throw error
    } finally {
      this.onTypingStop?.(queueItem.contextId)
    }
  }

  /**
   * –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤
   */
  private startContextCleanup(): void {
    const cleanup = () => {
      const now = Date.now()
      const maxAge = 24 * 60 * 60 * 1000 // 24 —á–∞—Å–∞

      for (const [contextId, context] of this.chatContexts.entries()) {
        if (now - context.lastActivity > maxAge) {
          this.chatContexts.delete(contextId)
          this.logger.d(`Cleaned up old context: ${contextId}`)
        }
      }
    }

    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ—á–∏—Å—Ç–∫—É –∫–∞–∂–¥—ã–π —á–∞—Å
    setInterval(cleanup, 60 * 60 * 1000)
  }

  /**
   * –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ –∏–∑ –ë–î
   */
  private async loadChatContexts(): Promise<void> {
    if (!this.chatAiRepository) {
      this.logger.d("No database connection, skipping context loading")
      return
    }

    try {
      const activeChats = await this.chatAiRepository.getActiveAiChats()
      for (const chat of activeChats) {
        this.chatSettings.set(chat.id, { chat, config: null })
      }
      this.logger.i(`Loaded ${activeChats.length} active AI chats`)
    } catch (error) {
      this.logger.e("Error loading chat contexts:", error)
    }
  }

  /**
   * –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–≤ –≤ –ë–î (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
   */
  private async saveChatContexts(): Promise<void> {
    if (!this.chatAiRepository) {
      this.logger.d("No database connection, skipping context saving")
      return
    }

    try {
      // –í —É–ø—Ä–æ—â–µ–Ω–Ω–æ–π —Å—Ö–µ–º–µ –º—ã –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç—ã –≤ –ë–î
      // –¢–æ–ª—å–∫–æ –æ–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–∞—Ç–æ–≤ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
      this.logger.d("Chat contexts saved (simplified)")
    } catch (error) {
      this.logger.e("Error saving chat contexts:", error)
    }
  }

  /**
   * –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–Ω–µ–≤–Ω–æ–≥–æ –ª–∏–º–∏—Ç–∞
   */
  setDailyLimit(limit: number): void {
    this.dailyLimit = Math.max(1, limit)
    this.logger.i(`Set daily limit: ${this.dailyLimit}`)
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
   */
  getContextStats(contextId: string): {
    messages: number
    requestCount: number
    dailyRequestCount: number
    remaining: number
  } | null {
    const context = this.chatContexts.get(contextId)
    if (!context)
      return null

    return {
      messages: context.messages.length,
      requestCount: context.requestCount,
      dailyRequestCount: context.dailyRequestCount,
      remaining: this.dailyLimit - context.dailyRequestCount,
    }
  }

  /**
   * –ö–æ–ª–±—ç–∫–∏ –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å TelegramBotService
   */
  public onMessageResponse?: (contextId: string, response: string, messageId: number) => void
  public onTypingStart?: (contextId: string) => void
  public onTypingStop?: (contextId: string) => void

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–∞—Ç–∞
   */
  async getChatSettings(chatId: number): Promise<{ chat: Chat | null, config: ChatConfig | null }> {
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
    if (this.chatSettings.has(chatId)) {
      const cached = this.chatSettings.get(chatId)!
      return { chat: cached.chat, config: cached.config }
    }

    // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ –ë–î
    if (this.chatAiRepository) {
      const result = await this.chatAiRepository.getChatWithConfig(chatId)
      if (result.chat && result.config) {
        this.chatSettings.set(chatId, result)
        return result
      }
    }

    return { chat: null, config: null }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å API –∫–ª—é—á –¥–ª—è —á–∞—Ç–∞ (–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π)
   */
  async getApiKeyForChat(chatId: number): Promise<string> {
    const { config } = await this.getChatSettings(chatId)
    return config?.geminiApiKey || this.config.AI_API_KEY
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º–ø—Ç –¥–ª—è —á–∞—Ç–∞
   */
  async getSystemPromptForChat(chatId: number): Promise<string | null> {
    const { config } = await this.getChatSettings(chatId)
    if (!config?.systemPrompt)
      return null

    return this.chatAiRepository?.buildSystemPromptString(config.systemPrompt) || null
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤–∫–ª—é—á–µ–Ω –ª–∏ –ò–ò –≤ —á–∞—Ç–µ
   */
  async isAiEnabledForChat(chatId: number): Promise<boolean> {
    const { config } = await this.getChatSettings(chatId)
    return config?.aiEnabled ?? true
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –ª–∏–º–∏—Ç—ã –¥–ª—è —á–∞—Ç–∞
   */
  async getChatLimits(chatId: number): Promise<{
    throttleDelay: number
  }> {
    const { config } = await this.getChatSettings(chatId)
    return {
      throttleDelay: config?.throttleDelay ?? this.throttleDelay,
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º —á–∞—Ç–∞
   */
  async isChatAdmin(chatId: number, userId: number): Promise<boolean> {
    if (!this.chatAiRepository)
      return false
    return await this.chatAiRepository.isAdmin(chatId, userId)
  }

  /**
   * –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —á–∞—Ç–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤)
   */
  async updateChatSettings(
    chatId: number,
    userId: number,
    updates: Partial<{
      geminiApiKey: string | null
      systemPrompt: SystemPromptData | null
      aiEnabled: boolean
      throttleDelay: number
    }>,
  ): Promise<boolean> {
    if (!this.chatAiRepository)
      return false

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
    const isAdmin = await this.isChatAdmin(chatId, userId)
    if (!isAdmin) {
      this.logger.w(`User ${userId} tried to update settings for chat ${chatId} without admin rights`)
      return false
    }

    const success = await this.chatAiRepository.updateChatConfig(chatId, updates)
    if (success) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
      this.chatSettings.delete(chatId)
      this.logger.i(`Chat ${chatId} settings updated by user ${userId}`)
    }

    return success
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–µ—Ä–≤–∏—Å–∞
   */
  getStats(): object {
    return {
      activeContexts: this.chatContexts.size,
      queueLength: this.messageQueue.length,
      dailyLimit: this.dailyLimit,
      isProcessing: this.isProcessingQueue,
      activeChats: this.chatSettings.size,
      serviceStatus: "active",
    }
  }
}
